
[백준 1753번 - 최단경로]



#include <iostream>
#include <vector>
#include <queue>
#include <climits> // INT_MAX를 사용하기 위해 포함

using namespace std;

const int INF = INT_MAX; // 무한대를 나타내는 값

int V, E, K; // 정점 개수, 간선 개수, 시작 정점
vector<pair<int, int>> adj[20001]; // 그래프의 인접 리스트
int dist[20001]; // 최단 거리를 저장하는 배열

void dijkstra() {
    // 우선순위 큐 선언. {거리, 정점}. 거리가 작은 순으로 정렬되도록 greater 사용
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;

    // 1. 시작점 초기화
    dist[K] = 0;
    pq.push({0, K}); // 우선순위 큐에 {거리, 시작점} 추가

    while (!pq.empty()) {
        // 2. 거리가 가장 짧은 정점 꺼내기
        int current_dist = pq.top().first;
        int current_node = pq.top().second;
        pq.pop();

        // 3. 이미 처리된 노드이거나 더 긴 경로인 경우 무시
        if (dist[current_node] < current_dist) {
            continue;
        }

        // 4. 현재 노드와 연결된 인접 노드들 확인
        for (int i = 0; i < adj[current_node].size(); i++) {
            int next_node = adj[current_node][i].first;
            int next_dist = adj[current_node][i].second;

            // 5. 더 짧은 경로 발견 시 거리 갱신 및 큐에 추가
            if (dist[next_node] > current_dist + next_dist) {
                dist[next_node] = current_dist + next_dist;
                pq.push({dist[next_node], next_node});
            }
        }
    }
}

int main() {
    // 입출력 속도 향상
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    cin >> V >> E >> K;

    // 간선 정보 입력받기
    for (int i = 0; i < E; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        adj[u].push_back({v, w});
    }

    // 최단 거리 배열 초기화
    for (int i = 1; i <= V; i++) {
        dist[i] = INF;
    }

    // 다익스트라 알고리즘 실행
    dijkstra();

    // 결과 출력
    for (int i = 1; i <= V; i++) {
        if (dist[i] == INF) {
            cout << "INF\n";
        } else {
            cout << dist[i] << "\n";
        }
    }

    return 0;
}
