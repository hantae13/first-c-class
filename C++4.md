8/3 정기 모임
[백준 7576번 토마토]

#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>

using namespace std;

int M, N;
int box[1001][1001];
queue<pair<int, int>> q;

// 상, 하, 좌, 우 네 방향
int dx[] = {0, 0, 1, -1};
int dy[] = {1, -1, 0, 0};

void bfs() {
    while (!q.empty()) {
        int y = q.front().first;
        int x = q.front().second;
        q.pop();

        for (int i = 0; i < 4; i++) {
            int ny = y + dy[i];
            int nx = x + dx[i];

            // 상자 범위를 벗어나지 않고, 익지 않은 토마토가 있는 경우
            if (nx >= 0 && ny >= 0 && nx < M && ny < N && box[ny][nx] == 0) {
                box[ny][nx] = box[y][x] + 1; // 날짜(거리)를 1 증가시켜 기록
                q.push({ny, nx});
            }
        }
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    cin >> M >> N;

    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            cin >> box[i][j];
            if (box[i][j] == 1) {
                q.push({i, j}); // 익은 토마토의 위치를 큐에 미리 추가
            }
        }
    }

    bfs();

    int max_days = 0;
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            // 익지 않은 토마토가 남아있다면 -1 출력
            if (box[i][j] == 0) {
                cout << -1 << endl;
                return 0;
            }
            // 최대 일수 갱신
            if (max_days < box[i][j]) {
                max_days = box[i][j];
            }
        }
    }

   
    cout << max_days - 1 << endl;

    return 0;
}



--------------------------------------------------------------------------
[백준 1806번 부분합]


#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

const int INF = 100001; // N의 최대값보다 큰 값으로 설정

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int N, S;
    cin >> N >> S;

    vector<int> arr(N);
    for (int i = 0; i < N; i++) {
        cin >> arr[i];
    }

    int start = 0;
    int end = 0;
    int sum = 0;
    int min_len = INF;

    while (end <= N) {
        // 현재 부분합이 S보다 크거나 같은 경우
        if (sum >= S) {
            min_len = min(min_len, end - start); // 최소 길이 갱신
            sum -= arr[start]; // 구간을 줄이기 위해 start 위치의 값을 빼고
            start++; // start를 오른쪽으로 이동
        }
        // 현재 부분합이 S보다 작은 경우
        else {
            if (end == N) break; // end가 배열의 끝에 도달하면 종료
            sum += arr[end]; // 구간을 넓히기 위해 end 위치의 값을 더하고
            end++; // end를 오른쪽으로 이동
        }
    }

    // 만약 min_len이 초기값 그대로이면, 합을 S 이상으로 만드는 경우가 없는 것
    if (min_len == INF) {
        cout << 0 << endl;
    } else {
        cout << min_len << endl;
    }

    return 0;
}

